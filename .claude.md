# Claude Development Guidelines for MeetingMuse

This file contains coding guidelines and best practices for Claude AI when working on the MeetingMuse project.

## 📋 Core Principles

### Type Safety & Data Modeling
- **Always use Pydantic models instead of dictionaries** for structured data
- This ensures type safety, validation, and better maintainability
- Follow the pattern established with `MeetingFindings` and `CalendarEventDetails` models
- Use proper type hints throughout the codebase

### Code Organization
- Follow the existing project structure and patterns
- Use dependency injection for services (see `dependencies.py`)
- Implement proper error handling with user-friendly messages
- Use async/await patterns for I/O operations
- **ALWAYS prefer Pydantic models over dictionaries** for structured data
- When interfacing with libraries that expect dictionaries, use `model.model_dump()` to convert Pydantic models

### Authentication & Security
- OAuth sessions are managed through `SessionManager` and `OAuthService`
- Session IDs are required for authenticated operations
- Never expose credentials or session tokens in logs
- Use proper encryption for sensitive data storage

## 🏗️ Architecture Guidelines

### Service Architecture
The application uses a layered service architecture with dependency injection:

#### Storage Layer
- **StorageAdapter**: Abstract interface for different storage backends (memory, Redis, database)
- **MemoryStorageAdapter**: In-memory implementation for development/testing

#### Session Management Layer
- **SessionManager**: Handles OAuth sessions with encryption/decryption and storage operations

#### Business Logic Layer
- **OAuthService**: Handles OAuth 2.0 flow using SessionManager for persistence

#### API Layer
- All services are injected via FastAPI dependency injection system
- Use `get_*()` functions in `dependencies.py` for service instances

### Storage Adapter Pattern
- Use adapter pattern for swappable storage backends
- Storage adapters implement the `StorageAdapter` interface
- Easy to swap from memory to Redis/database by changing adapter in dependencies

### Node Development
- All nodes must inherit from `BaseNode`
- Use `@log_node_entry` decorator for consistent logging
- Handle errors gracefully and provide meaningful user feedback
- Return appropriate `Command` objects for workflow control

### API Integration
- Use Google API client libraries with proper error handling
- Implement retry logic for transient failures
- Parse user input flexibly (dates, durations, etc.)
- Return structured Pydantic models, not raw dictionaries

### State Management
- `MeetingMuseBotState` is the central state object
- Include `session_id` for authenticated operations
- Update state immutably where possible
- Use proper field validation

## 📝 Model Guidelines

### Pydantic Models
```python
#  Good - Use Pydantic models
class CalendarEventDetails(BaseModel):
    event_id: str
    event_link: Optional[str] = None
    start_time: str
    end_time: str

#  Bad - Avoid raw dictionaries
def create_event() -> Dict[str, Any]:
    return {"event_id": "123", "link": None}
```

### Type Annotations
```python
#  Good - Proper type hints
async def create_calendar_event(state: MeetingMuseBotState) -> CalendarEventDetails:
    pass

#  Bad - Missing or generic types
def create_calendar_event(state) -> dict:
    pass
```

## 🔧 Development Patterns

### Error Handling
```python
#  Good - Specific error handling
try:
    event = await self._create_calendar_event(state)
    return Command(goto=NodeName.END)
except ValueError as ve:
    # Handle authentication errors
    error_msg = f"Authentication error: {str(ve)}"
    state.messages.append(AIMessage(content=f" {error_msg}"))
    return Command(goto=NodeName.HUMAN_INTERRUPT_RETRY)
except Exception as e:
    # Handle unexpected errors
    error_msg = f"Failed to schedule meeting: {str(e)}"
    state.messages.append(AIMessage(content=f" {error_msg}"))
    return Command(goto=NodeName.HUMAN_INTERRUPT_RETRY)
```

### Service Integration
```python
#  Good - Use dependency injection
def __init__(self, model: HuggingFaceModel, logger: Logger, oauth_service: OAuthService):
    super().__init__(logger)
    self.model = model
    self.oauth_service = oauth_service

#  Bad - Direct instantiation
def __init__(self, model: HuggingFaceModel, logger: Logger):
    super().__init__(logger)
    self.oauth_service = OAuthService()  # Hard-coded dependency
```

## 🧪 Testing Guidelines

- Write tests for new models and nodes
- Mock external API calls (Google Calendar, etc.)
- Test error conditions and edge cases
- Ensure type safety with mypy validation

## 🚨 Common Pitfalls to Avoid

1. **Dictionary Returns** - Always use Pydantic models for structured data
2. **Missing Type Hints** - Include proper type annotations
3. **Hard-coded Dependencies** - Use dependency injection
4. **Poor Error Messages** - Provide user-friendly error messages
5. **Session Handling** - Always check for session_id in authenticated operations
6. **Import Errors** - Use correct import paths and class names

## 📚 Project Structure Reference

```
src/
├── meetingmuse/           # Core conversation logic
│   ├── models/           # Pydantic models (USE THESE!)
│   ├── nodes/            # Conversation flow nodes
│   └── services/         # Business logic services
├── server/               # FastAPI web server
│   ├── api/             # REST and WebSocket endpoints
│   ├── services/        # Server-side services
│   └── storage/         # Data persistence layer
└── common/              # Shared utilities
```

This file should be updated as the project evolves and new patterns emerge.
